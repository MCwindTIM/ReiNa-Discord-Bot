const Discord = require("discord.js");
const util = require('../util.js');
const Canvas = require('canvas');
module.exports.run = async (bot, message, args) =>{
	message.delete();
	let kitisgay = message.mentions.members.first();
	if(!kitisgay){
		let embed = new Discord.RichEmbed()
		embed
		.setDescription("è«‹æä¾›@æƒ³é©—è­‰çš„ç”¨æˆ¶")
		.setColor(0xcc0000)
		.setTitle('ReiNa Bot éŒ¯èª¤')
		.setURL("https://mcwind.tk")
		.addField('ä½¿ç”¨æ–¹æ³•: ', "rn!lie [ç”¨æˆ¶]")
		.setTimestamp()
		.setFooter('ReiNa By ğ“–ğ“»ğ“ªğ“·ğ“­ğ“ğ“¹ğ“®ğ“»ğ“ªğ“½ğ“¸ğ“»#9487', bot.user.avatarURL);
		try {
			util.sendDeletableMessage(message.channel, { embed }, message.author);
		}   catch (err) {
				console.error(err);
		}
		return;
	}
	const canvas = Canvas.createCanvas(100, 30);
	const ctx = canvas.getContext('2d');
	const blankbg = await Canvas.loadImage('./blankbg.jpg');
	ctx.drawImage(blankbg, 0, 0, canvas.width, canvas.height);
	ctx.font = '24px "Microsoft YaHei"';

	let drawText = (text, x) => {
		ctx.save();
		const angle = Math.random() / 10;
		const y = 22;
		ctx.rotate(angle);
		ctx.fillText(text, x, y);
		ctx.restore();
	}

	let drawLine = () => {
		const num = Math.floor(Math.random() * 2 + 3);

		for(let i = 0; i < num; i++){
		const color = '#' + (Math.random() * 0xffffff << 0).toString(16);
		const y1 = Math.random() * canvas.height;
		const y2 = Math.random() * canvas.height;
		ctx.strokeStyle = color;
		ctx.beginPath();
		ctx.lineTo(0, y1);
		ctx.lineTo(canvas.width, y2);
		ctx.stroke();
		}
	}

	const numArr = [
	'ã€‡ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹',
	'0123456789',
	'é›¶å£¹è´°åè‚†ä¼é™†æŸ’æŒç–'
	];

	const fir = Math.floor(Math.random() * 10);
	const sec = Math.floor(Math.random() * 10);
	const operArr = ['åŠ ', 'å‡', 'ä¹˜'];
	const oper = Math.floor(Math.random() * operArr.length);

	drawLine();
	drawText(numArr[Math.floor(Math.random() * numArr.length)][fir], 10);
	drawText(operArr[oper], 40);
	drawText(numArr[Math.floor(Math.random() * numArr.length)][sec], 70);
	drawText('=', 100);
	drawText('?', 130);

	let captcha;
	switch(oper) {
	  case 0: 
		captcha = fir + sec;
		break;
	  case 1:
		captcha = fir - sec;
		break;
	  case 2:
		captcha = fir * sec;
		break;
	}
	const attachment = new Discord.Attachment(canvas.toBuffer(), 'æ¸¬è¬Šæ©Ÿ.png');

	message.channel.send(`${message.mentions.members.first()}, è«‹åœ¨äº”ç§’å…§è¼¸å…¥èªè­‰ç¢¼!`, attachment).then(message => {
		message.delete(5000).catch(console.log(error))
	});
	try {
		var response = await message.channel.awaitMessages(message2 => message2.content > captcha - 1 && message2.content < captcha + 1, {
			maxMatches: 1,
			time: 5000,
			errors: ['time']
		});
		const fetched = await message.channel.fetchMessages({limit: 1});
		message.channel.bulkDelete(fetched)
	} catch (err) {
		const embed = new Discord.RichEmbed()
		embed
		.setAuthor(message.author.tag, message.author.avatarURL)
		.setDescription(`${message.mentions.members.first()}` + "èªè­‰ç¢¼éŒ¯èª¤ / è¶…éè¼¸å…¥æ™‚é–“!")
		.setColor(0xcc0000)
		.setTitle('ReiNa Bot é©—è­‰éŒ¯èª¤')
		.setURL("https://mcwind.tk")
		.setTimestamp()
		.setFooter('ReiNa By ğ“–ğ“»ğ“ªğ“·ğ“­ğ“ğ“¹ğ“®ğ“»ğ“ªğ“½ğ“¸ğ“»#9487', bot.user.avatarURL);
		util.sendDeletableMessage(message.channel, { embed }, message.author);
		let userVC =message.mentions.members.first().voiceChannel;
		let offlineVC = bot.channels.find(x => x.name === "ğŸ’¤éš±èº«/é›¢ç·š/é©—è­‰å¤±æ•—");
		if(userVC){
			try{
				message.mentions.members.first().setVoiceChannel(offlineVC);
			}
			catch(e){}
		}
		return;
		}
	let embed = new Discord.RichEmbed()
	embed
	.setAuthor(message.author.tag, message.author.avatarURL)
	.setDescription(`${message.mentions.members.first()}` + "é€šéèªè­‰!")
	.setColor(0xcc0000)
	.setTitle('ReiNa Bot')
	.setURL("https://mcwind.tk")
	.setTimestamp()
	.setFooter('ReiNa By ğ“–ğ“»ğ“ªğ“·ğ“­ğ“ğ“¹ğ“®ğ“»ğ“ªğ“½ğ“¸ğ“»#9487', bot.user.avatarURL);
	util.sendDeletableMessage(message.channel, { embed }, message.author);
}

module.exports.help = {
	name: "lie",
	description: "testing",
	cate: 8,
	show: true
	
}
